# Session Health Monitoring - Internal Python API Contract

# This is an internal Python API (not HTTP REST API)
# Documenting the public interface of the SessionHealthMonitor service

## SessionHealthMonitor Public Interface

### check_health() -> HealthCheckResult
"""
Execute immediate health check and return result.

Returns:
    HealthCheckResult: Health check outcome with latency, success status, error details

Side Effects:
    - Updates session metrics (health_check_count, last_health_check)
    - Triggers reauth if session invalid (FR-003)
    - Records failure in circuit breaker if reauth fails (FR-005)
    - Logs health check event to structured logger (FR-009)

Raises:
    RuntimeError: If circuit breaker tripped (bot should halt)
"""

### get_session_status() -> SessionHealthStatus
"""
Get current session health metrics.

Returns:
    SessionHealthStatus: Session metrics (uptime, reauth count, last check time)

No side effects - read-only operation.
"""

### start_periodic_checks() -> None
"""
Start periodic health checks on 5-minute timer.

Side Effects:
    - Starts background timer thread
    - Executes check_health() every 5 minutes (FR-006)
    - Timer auto-repeats until stop_periodic_checks() called

Idempotent: Safe to call multiple times (no-op if timer already running)
"""

### stop_periodic_checks() -> None
"""
Stop periodic health checks timer.

Side Effects:
    - Cancels background timer thread
    - No more automatic health checks until start_periodic_checks() called

Idempotent: Safe to call multiple times (no-op if timer not running)
"""

## Data Structures

### SessionHealthStatus
```python
@dataclass
class SessionHealthStatus:
    is_healthy: bool                    # Current session validity
    session_start_time: datetime        # When session established (UTC)
    session_uptime_seconds: int         # Duration since session start
    last_health_check: datetime         # Timestamp of last check (UTC)
    health_check_count: int             # Total checks this session
    reauth_count: int                   # Number of reauths this session
    consecutive_failures: int           # Current failure streak
```

### HealthCheckResult
```python
@dataclass
class HealthCheckResult:
    success: bool                       # Health check passed/failed
    timestamp: datetime                 # When check executed (UTC)
    latency_ms: int                     # Check duration in milliseconds
    error_message: Optional[str]        # If failed, error details
    reauth_triggered: bool              # Whether reauth was attempted
```

## Integration Points

### TradingBot.execute_trade() - Pre-Trade Health Check (FR-007)
```python
def execute_trade(self, symbol, action, shares, price, reason):
    # Pre-trade health check
    health_result = self.health_monitor.check_health()

    if not health_result.success:
        logger.error(f"Trade blocked - health check failed: {health_result.error_message}")
        return  # Abort trade

    # Proceed with trade execution...
```

### TradingBot.start() - Start Periodic Checks
```python
def start(self):
    # ... existing startup logic ...

    # Start periodic health checks
    self.health_monitor.start_periodic_checks()
    logger.info("Periodic health checks started (5 min interval)")
```

### TradingBot.stop() - Stop Periodic Checks
```python
def stop(self):
    # Stop periodic health checks
    self.health_monitor.stop_periodic_checks()
    logger.info("Periodic health checks stopped")

    # ... existing shutdown logic ...
```

## Structured Log Events (JSONL)

### health_check.executed
```json
{
  "event": "health_check.executed",
  "timestamp": "2025-10-09T14:32:15.123Z",
  "session_id": "abc-123-def",
  "latency_ms": 127,
  "context": "periodic" | "pre_trade"
}
```

### health_check.passed
```json
{
  "event": "health_check.passed",
  "timestamp": "2025-10-09T14:32:15.250Z",
  "session_id": "abc-123-def",
  "session_uptime_seconds": 3600
}
```

### health_check.failed
```json
{
  "event": "health_check.failed",
  "timestamp": "2025-10-09T14:32:15.250Z",
  "session_id": "abc-123-def",
  "error_type": "AuthenticationError",
  "context": "periodic" | "pre_trade"
}
```

### health_check.reauth_triggered
```json
{
  "event": "health_check.reauth_triggered",
  "timestamp": "2025-10-09T14:32:16.000Z",
  "session_id": "abc-123-def",
  "attempt": 1
}
```

### health_check.reauth_success
```json
{
  "event": "health_check.reauth_success",
  "timestamp": "2025-10-09T14:32:25.000Z",
  "session_id": "abc-123-def",
  "reauth_latency_ms": 9000
}
```

### health_check.reauth_failed
```json
{
  "event": "health_check.reauth_failed",
  "timestamp": "2025-10-09T14:32:40.000Z",
  "session_id": "abc-123-def",
  "error_message": "All retry attempts exhausted",
  "circuit_breaker_tripped": true
}
```

### session.metrics_snapshot
```json
{
  "event": "session.metrics_snapshot",
  "timestamp": "2025-10-09T14:45:00.000Z",
  "session_id": "abc-123-def",
  "session_uptime_seconds": 4500,
  "health_check_count": 15,
  "reauth_count": 0,
  "consecutive_failures": 0,
  "is_healthy": true
}
```

## Performance Guarantees

- **Health Check Latency**: P95 <2s, P99 <5s (NFR-001)
- **Trade Execution Overhead**: <100ms (cached result if checked within 10s) (NFR-002)
- **Pass Rate**: >95% (excluding actual auth failures) (NFR-003)

## Error Handling

### Retriable Errors (Exponential Backoff: 1s, 2s, 4s)
- Network timeouts (ConnectionError, TimeoutError)
- Temporary API failures (503 Service Unavailable)
- Rate limits (429 Too Many Requests)

### Non-Retriable Errors (Immediate Failure)
- Invalid credentials (401 Unauthorized) → Trigger reauth
- Authentication failures after reauth → Trip circuit breaker, halt bot

### Circuit Breaker Trip Conditions
- 5 consecutive health check failures in 60 seconds
- Reauth fails after retry exhaustion
- Action: Halt bot, log critical error, require manual restart
