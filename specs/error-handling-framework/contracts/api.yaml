# API Contract: Error Handling Framework
# This is a Python module (not REST API), so this documents the public Python API

---
module: trading_bot.error_handling
version: 1.0.0
description: Centralized error handling framework with retry logic and circuit breaker

## Public API

### Decorators

with_retry:
  description: Decorator to add exponential backoff retry logic to a function
  signature: |
    @with_retry(
        policy: RetryPolicy | None = None,
        on_retry: Callable[[Exception, int], None] | None = None,
        on_exhausted: Callable[[Exception], None] | None = None
    )
  parameters:
    - name: policy
      type: RetryPolicy | None
      default: DEFAULT_POLICY
      description: Retry configuration (max_attempts, backoff, jitter)
    - name: on_retry
      type: Callable[[Exception, int], None] | None
      default: None
      description: Callback function called on each retry attempt (exception, attempt_number)
    - name: on_exhausted
      type: Callable[[Exception], None] | None
      default: None
      description: Callback function called when all retries exhausted (final exception)
  returns:
    type: Callable
    description: Decorated function with retry logic
  raises:
    - Exception: Re-raises last exception after all retries exhausted
  example: |
    from trading_bot.error_handling import with_retry, RetriableError

    @with_retry()
    def fetch_data():
        # May raise RetriableError (network, timeout, 5xx)
        return api.get("/data")

    @with_retry(policy=AGGRESSIVE_POLICY)
    def critical_operation():
        # Retries 5 times instead of default 3
        return api.post("/critical")

### Exception Classes

RetriableError:
  description: Base exception for errors that should trigger retry
  inherits: Exception
  use_cases:
    - Network errors (connection timeout, DNS failure)
    - Temporary server errors (5xx status codes)
    - Rate limiting (HTTP 429)
    - Transient database errors
  example: |
    raise RetriableError("Network timeout - connection failed")

NonRetriableError:
  description: Base exception for errors that should fail fast (no retry)
  inherits: Exception
  use_cases:
    - Client errors (4xx status codes except 429)
    - Validation errors (bad input)
    - Authentication failures (401, 403)
    - Resource not found (404)
  example: |
    raise NonRetriableError("Bad request - invalid parameters")

RateLimitError:
  description: Specific exception for HTTP 429 rate limiting
  inherits: RetriableError
  attributes:
    - name: retry_after
      type: int
      description: Seconds to wait before retry (from Retry-After header)
  example: |
    raise RateLimitError("Rate limit exceeded", retry_after=60)

### Configuration Classes

RetryPolicy:
  description: Configuration dataclass for retry behavior
  type: dataclass
  fields:
    - name: max_attempts
      type: int
      default: 3
      description: Maximum number of retry attempts (not including initial call)
      validation: Must be > 0
    - name: base_delay
      type: float
      default: 1.0
      description: Base delay in seconds for exponential backoff
      validation: Must be > 0
    - name: backoff_multiplier
      type: float
      default: 2.0
      description: Multiplier for exponential backoff (1s, 2s, 4s with default 2.0)
      validation: Must be >= 1.0
    - name: jitter
      type: bool
      default: True
      description: Add ±10% randomness to delays to prevent thundering herd
    - name: retriable_exceptions
      type: tuple[type[Exception], ...]
      default: (RetriableError,)
      description: Tuple of exception types that should trigger retry
  example: |
    from trading_bot.error_handling import RetryPolicy

    custom_policy = RetryPolicy(
        max_attempts=5,
        base_delay=2.0,
        backoff_multiplier=3.0,
        jitter=False
    )

    @with_retry(policy=custom_policy)
    def my_function():
        pass

### Predefined Policies

DEFAULT_POLICY:
  description: Default retry policy (3 attempts, 1s base, 2x backoff, jitter)
  value: RetryPolicy(max_attempts=3, base_delay=1.0, backoff_multiplier=2.0, jitter=True)
  retry_delays: [1s, 2s, 4s] (approximately, with jitter)

AGGRESSIVE_POLICY:
  description: More aggressive retry policy (5 attempts)
  value: RetryPolicy(max_attempts=5, base_delay=1.0, backoff_multiplier=2.0, jitter=True)
  retry_delays: [1s, 2s, 4s, 8s, 16s] (approximately, with jitter)

CONSERVATIVE_POLICY:
  description: Conservative retry policy (1 attempt only - effectively no retry)
  value: RetryPolicy(max_attempts=1, base_delay=1.0, backoff_multiplier=2.0, jitter=False)
  retry_delays: [] (fails fast on first error)

### Circuit Breaker

circuit_breaker:
  description: Singleton instance for tracking consecutive errors
  type: CircuitBreaker
  methods:
    - name: record_failure
      signature: record_failure() -> None
      description: Record an API failure (adds timestamp to sliding window)
    - name: record_success
      signature: record_success() -> None
      description: Record an API success (resets error window)
    - name: should_trip
      signature: should_trip() -> bool
      description: Check if circuit breaker should trip (>= threshold errors in window)
      returns: True if should trigger graceful shutdown, False otherwise
  configuration:
    - threshold: 5 (errors to trigger shutdown)
    - window_seconds: 60 (time window for counting errors)
  example: |
    from trading_bot.error_handling import circuit_breaker

    def api_call():
        try:
            result = external_api.fetch()
            circuit_breaker.record_success()
            return result
        except Exception as e:
            circuit_breaker.record_failure()
            if circuit_breaker.should_trip():
                logger.critical("Circuit breaker tripped - shutting down")
                sys.exit(1)
            raise

## Usage Examples

### Example 1: Basic Retry
```python
from trading_bot.error_handling import with_retry, RetriableError

@with_retry()
def fetch_buying_power():
    # Automatically retries on RetriableError
    response = robinhood_api.get_account()
    if not response:
        raise RetriableError("Empty response from API")
    return float(response['buying_power'])
```

### Example 2: Custom Retry Policy
```python
from trading_bot.error_handling import with_retry, RetryPolicy, RetriableError

critical_policy = RetryPolicy(max_attempts=5, base_delay=2.0)

@with_retry(policy=critical_policy)
def place_order(symbol, quantity, price):
    # Critical operation - retry 5 times with 2s base delay
    response = robinhood_api.place_order(symbol, quantity, price)
    if response.status_code >= 500:
        raise RetriableError(f"Server error: {response.status_code}")
    return response
```

### Example 3: Retry with Callbacks
```python
from trading_bot.error_handling import with_retry, RetriableError

def on_retry_callback(error: Exception, attempt: int):
    logger.warning(f"Retry attempt {attempt}: {error}")
    # Could also: send alert, update metrics, etc.

def on_exhausted_callback(error: Exception):
    logger.critical(f"All retries exhausted: {error}")
    # Could also: trigger fallback logic, send critical alert

@with_retry(
    on_retry=on_retry_callback,
    on_exhausted=on_exhausted_callback
)
def risky_operation():
    return external_api.fetch()
```

### Example 4: Rate Limit Handling
```python
from trading_bot.error_handling import with_retry, RateLimitError
import requests

@with_retry()
def api_call_with_rate_limit():
    response = requests.get("https://api.example.com/data")
    if response.status_code == 429:
        retry_after = int(response.headers.get('Retry-After', 60))
        raise RateLimitError("Rate limit exceeded", retry_after=retry_after)
    return response.json()
```

### Example 5: Migrate Existing Code
```python
# BEFORE: Duplicate retry logic
def _fetch_buying_power(self) -> float:
    last_exception = None
    for attempt in range(3):
        try:
            return self._api_call()
        except Exception as e:
            last_exception = e
            if attempt < 2:
                delay = 1.0 * (2 ** attempt)
                time.sleep(delay)
    raise last_exception

# AFTER: Using framework
from trading_bot.error_handling import with_retry

@with_retry()
def _fetch_buying_power(self) -> float:
    return self._api_call()
```

## Integration with Existing Codebase

### Preserve Existing Exception Classes
```python
# Existing custom errors can inherit from framework base classes

from trading_bot.error_handling import RetriableError, NonRetriableError

# Retriable errors (network, timeout, temporary failures)
class AccountDataError(RetriableError):
    """Temporary account data fetch error - will retry"""
    pass

# Non-retriable errors (validation, auth, permanent failures)
class AuthenticationError(NonRetriableError):
    """Authentication failed - won't retry"""
    pass
```

### Logging Integration
```python
# Framework automatically integrates with TradingLogger

from trading_bot.logger import TradingLogger
from trading_bot.error_handling import with_retry

# All retry attempts logged to errors.log via TradingLogger.get_errors_logger()
# Log format: "Attempt {N}/{max}: {exception}. Retrying in {delay}s..."
```

## Error Handling Flow

```
User calls decorated function
  ↓
@with_retry catches exception
  ↓
Is exception type in retriable_exceptions?
  ├─ No → Raise immediately (fail fast)
  └─ Yes → Continue to retry logic
      ↓
Is exception RateLimitError?
  ├─ Yes → Wait for retry_after seconds
  └─ No → Calculate exponential backoff
      ↓
Apply jitter (±10% randomness if enabled)
  ↓
Sleep for calculated delay
  ↓
Retry function call (attempt N)
  ↓
Success?
  ├─ Yes → Return result
  └─ No → Repeat until max_attempts reached
      ↓
All retries exhausted?
  ↓
Call on_exhausted callback (if provided)
  ↓
Log final failure to errors.log
  ↓
Re-raise last exception with full stack trace
```

## Testing Contract

All public APIs are 100% unit tested with:
- Success path (function returns result)
- Retry path (function fails then succeeds)
- Exhaustion path (all retries fail)
- Rate limit path (HTTP 429 with Retry-After)
- Circuit breaker path (5 failures trigger shutdown)
- Edge cases (invalid policy, zero attempts, etc.)

Coverage target: ≥90% line and branch coverage
