# Python API Contracts: Zone Breakout Detection

## NOTE: This is an internal Python library, not a REST API
## This file documents Python function contracts for reference

---

## BreakoutDetector API

### detect_breakout()

**Purpose**: Detect if current price/volume represents a breakout through a zone

**Signature**:
```python
def detect_breakout(
    zone: Zone,
    current_price: Decimal,
    current_volume: Decimal,
    historical_volumes: list[Decimal]
) -> BreakoutSignal | None
```

**Parameters**:
- `zone`: Zone object from ZoneDetector.detect_zones()
  - Type: Zone (from src.trading_bot.support_resistance.models)
  - Constraints: Must be valid Zone with price_level > 0, zone_type in [SUPPORT, RESISTANCE]
- `current_price`: Current market price for the symbol
  - Type: Decimal
  - Constraints: Must be > 0
  - Source: MarketDataService.get_quote().price
- `current_volume`: Current trading volume
  - Type: Decimal
  - Constraints: Must be >= 0
  - Source: MarketDataService.get_quote().volume
- `historical_volumes`: List of recent volumes for average calculation
  - Type: list[Decimal]
  - Constraints: Length >= 20 (for 20-bar average), all values >= 0
  - Source: MarketDataService.get_historical_data(days=20)

**Returns**:
- `BreakoutSignal | None`
  - None: No breakout detected (price <1% or volume <1.3x)
  - BreakoutSignal: Contains zone, event, flipped_zone

**BreakoutSignal Structure**:
```python
@dataclass
class BreakoutSignal:
    zone: Zone  # Original zone that was broken
    event: BreakoutEvent  # Breakout event with full metadata
    flipped_zone: Zone  # New zone with flipped type and +2 strength
```

**Raises**:
- `ValueError`: If zone is invalid or current_price/volume are negative
- `DataValidationError`: If historical_volumes is empty or has invalid data

**Examples**:
```python
# Success case: Resistance breakout
zone = Zone(price_level=Decimal("155.00"), zone_type=ZoneType.RESISTANCE, ...)
signal = detector.detect_breakout(
    zone=zone,
    current_price=Decimal("156.60"),  # +1.03%
    current_volume=Decimal("1400000"),  # Current volume
    historical_volumes=[Decimal("1000000")] * 20  # Avg = 1M, ratio = 1.4x
)
assert signal is not None
assert signal.event.volume_ratio == Decimal("1.4")
assert signal.flipped_zone.zone_type == ZoneType.SUPPORT

# Failure case: Insufficient price move
signal = detector.detect_breakout(
    zone=zone,
    current_price=Decimal("155.50"),  # +0.32% (below 1% threshold)
    current_volume=Decimal("1400000"),
    historical_volumes=[Decimal("1000000")] * 20
)
assert signal is None  # No breakout
```

**Performance**:
- Target: <200ms (NFR-001)
- Typical: <50ms for single zone check

---

### flip_zone()

**Purpose**: Create new Zone instance with flipped type and updated strength

**Signature**:
```python
def flip_zone(
    zone: Zone,
    breakout_event: BreakoutEvent
) -> Zone
```

**Parameters**:
- `zone`: Original zone to flip
  - Type: Zone
  - Constraints: Must have valid zone_type (SUPPORT or RESISTANCE)
- `breakout_event`: Triggering breakout event
  - Type: BreakoutEvent
  - Constraints: Must have old_zone_type matching zone.zone_type

**Returns**:
- `Zone`: New Zone instance with:
  - zone_type flipped (RESISTANCE → SUPPORT or SUPPORT → RESISTANCE)
  - strength_score += 2 (breakout bonus per FR-005)
  - breakout_events list appended with new event (US4)
  - All other metadata preserved (price_level, touch_count, dates, volumes)

**Raises**:
- `ValueError`: If zone_type doesn't match breakout_event.old_zone_type

**Examples**:
```python
zone = Zone(
    price_level=Decimal("155.00"),
    zone_type=ZoneType.RESISTANCE,
    strength_score=Decimal("5.0"),
    ...
)

event = BreakoutEvent(
    old_zone_type=ZoneType.RESISTANCE,
    new_zone_type=ZoneType.SUPPORT,
    ...
)

flipped = detector.flip_zone(zone, event)

assert flipped.zone_type == ZoneType.SUPPORT
assert flipped.strength_score == Decimal("7.0")  # 5.0 + 2.0 bonus
assert flipped.price_level == zone.price_level  # Preserved
assert len(flipped.breakout_events) == 1
```

**Performance**:
- Target: <10ms
- Typical: <1ms (simple dataclass construction)

---

## ZoneLogger API Extension

### log_breakout_event()

**Purpose**: Log breakout event to daily JSONL file with thread safety

**Signature**:
```python
def log_breakout_event(
    event: BreakoutEvent
) -> None
```

**Parameters**:
- `event`: BreakoutEvent to log
  - Type: BreakoutEvent
  - Constraints: Must have valid zone_id, prices > 0, UTC timestamp

**Returns**:
- None (side effect: writes to logs/zones/breakouts-YYYY-MM-DD.jsonl)

**Side Effects**:
- Writes JSON line to daily log file
- Creates log directory if doesn't exist (logs/zones/)
- Thread-safe write with file locking

**File Format** (JSONL):
```json
{
  "event": "breakout_detected",
  "timestamp": "2025-10-21T12:34:56.789Z",
  "symbol": "AAPL",
  "zone_id": "resistance_155.50_daily",
  "breakout_price": "156.60",
  "close_price": "156.60",
  "volume": "1400000",
  "volume_ratio": "1.40",
  "old_zone_type": "resistance",
  "new_zone_type": "support",
  "status": "pending",
  "timeframe": "daily"
}
```

**Raises**:
- None (graceful degradation - logs to stderr on OSError, continues execution)

**Examples**:
```python
logger = ZoneLogger(log_dir=Path("logs/zones"))

event = BreakoutEvent(
    event_id=str(uuid.uuid4()),
    zone_id="resistance_155.50_daily",
    timestamp=datetime.now(UTC),
    breakout_price=Decimal("156.60"),
    close_price=Decimal("156.60"),
    volume=Decimal("1400000"),
    volume_ratio=Decimal("1.40"),
    old_zone_type=ZoneType.RESISTANCE,
    new_zone_type=ZoneType.SUPPORT,
    status=BreakoutStatus.PENDING,
    symbol="AAPL",
    timeframe=Timeframe.DAILY
)

logger.log_breakout_event(event)  # Writes to logs/zones/breakouts-2025-10-21.jsonl
```

**Performance**:
- Target: <5ms per write (existing ZoneLogger performance)
- Typical: <2ms with buffering

---

## BreakoutConfig API

### from_env()

**Purpose**: Load configuration from environment variables with defaults

**Signature**:
```python
@classmethod
def from_env(cls) -> BreakoutConfig
```

**Parameters**: None (class method)

**Returns**:
- `BreakoutConfig`: Configuration instance with values from env vars or defaults

**Environment Variables**:
- `BREAKOUT_PRICE_THRESHOLD_PCT`: Price movement threshold % (default: 1.0)
- `BREAKOUT_VOLUME_THRESHOLD`: Volume multiplier threshold (default: 1.3)
- `BREAKOUT_VALIDATION_BARS`: Whipsaw validation window in bars (default: 5)
- `BREAKOUT_STRENGTH_BONUS`: Strength score bonus on flip (default: 2.0)

**Defaults** (from spec.md FR-001, FR-002, US5):
```python
BreakoutConfig(
    price_threshold_pct=Decimal("1.0"),  # FR-001: >1% required
    volume_threshold=Decimal("1.3"),  # FR-002: >1.3x average
    validation_bars=5,  # US5: 5-bar whipsaw window
    strength_bonus=Decimal("2.0")  # FR-005: +2 strength on flip
)
```

**Raises**:
- `ValueError`: If validation fails (negative values, out-of-range thresholds)

**Examples**:
```python
# Load with defaults
config = BreakoutConfig.from_env()
assert config.price_threshold_pct == Decimal("1.0")

# Load with custom env vars
os.environ["BREAKOUT_PRICE_THRESHOLD_PCT"] = "1.5"
os.environ["BREAKOUT_VOLUME_THRESHOLD"] = "1.5"

config = BreakoutConfig.from_env()
assert config.price_threshold_pct == Decimal("1.5")
assert config.volume_threshold == Decimal("1.5")
```

---

## Data Models

### BreakoutEvent

**Immutable dataclass with validation**

```python
@dataclass(frozen=True)
class BreakoutEvent:
    event_id: str  # UUID
    zone_id: str  # Reference to zone (e.g., "resistance_155.50_daily")
    timestamp: datetime  # UTC timezone required
    breakout_price: Decimal  # Price at breakout
    close_price: Decimal  # Closing price confirming breakout
    volume: Decimal  # Trading volume at breakout
    volume_ratio: Decimal  # vs 20-bar average (must be > 1.3)
    old_zone_type: ZoneType  # RESISTANCE or SUPPORT
    new_zone_type: ZoneType  # Flipped type
    status: BreakoutStatus  # PENDING, CONFIRMED, or WHIPSAW
    symbol: str  # Stock symbol (e.g., "AAPL")
    timeframe: Timeframe  # DAILY or FOUR_HOUR

    def __post_init__(self) -> None:
        # Validation (see data-model.md for full rules)
        ...

    def to_dict(self) -> dict[str, Any]:
        # Returns dict with ISO timestamps, string Decimals
        ...

    def to_jsonl_line(self) -> str:
        # Returns single-line JSON for logging
        ...
```

### BreakoutStatus

**Enum for breakout validation state**

```python
class BreakoutStatus(Enum):
    PENDING = "pending"  # Within 5-bar validation window
    CONFIRMED = "confirmed"  # Sustained >5 bars
    WHIPSAW = "whipsaw"  # Failed within 5 bars
```

---

## Integration Example

**Complete workflow from zone detection to breakout logging**:

```python
from src.trading_bot.support_resistance import (
    ZoneDetector, BreakoutDetector, ZoneLogger,
    ZoneDetectionConfig, BreakoutConfig
)
from src.trading_bot.market_data import MarketDataService

# Initialize services
market_data = MarketDataService(auth)
zone_logger = ZoneLogger()

zone_detector = ZoneDetector(
    config=ZoneDetectionConfig.from_env(),
    market_data_service=market_data,
    zone_logger=zone_logger
)

breakout_detector = BreakoutDetector(
    config=BreakoutConfig.from_env(),
    market_data_service=market_data,
    logger=zone_logger
)

# Detect zones
symbol = "AAPL"
zones = zone_detector.detect_zones(symbol, days=60)  # Returns list[Zone]

# Get current market data
quote = market_data.get_quote(symbol)  # Returns Quote
historical = market_data.get_historical_data(symbol, days=20)  # Returns list[PriceBar]
volumes = [bar.volume for bar in historical[-20:]]

# Check for breakouts
for zone in zones:
    signal = breakout_detector.detect_breakout(
        zone=zone,
        current_price=quote.price,
        current_volume=quote.volume,
        historical_volumes=volumes
    )

    if signal:
        # Breakout detected!
        print(f"Zone {zone.zone_id} broken")
        print(f"Flipped to {signal.flipped_zone.zone_type.value}")
        # Use signal.flipped_zone in subsequent trading logic
```
