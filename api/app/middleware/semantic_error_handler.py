"""Semantic error handler middleware for FastAPI.

Global exception handler that converts all exceptions to SemanticError format
with LLM-friendly fields (cause, impact, remediation).
"""

from fastapi import Request
from fastapi.responses import JSONResponse
from typing import Dict, Any

from src.trading_bot.logging.error_formatter import format_exception
from src.trading_bot.logging.structured_logger import StructuredTradeLogger
from pathlib import Path


# Global logger instance for error logging
error_logger = StructuredTradeLogger(log_dir=Path("logs"))


async def global_exception_handler(
    request: Request,
    exc: Exception
) -> JSONResponse:
    """
    Global exception handler for all FastAPI routes.

    Converts any exception to SemanticError format and returns JSON response
    with HTTP status code based on error type.

    Args:
        request: FastAPI request object
        exc: Exception that was raised

    Returns:
        JSONResponse with semantic error details

    Examples:
        >>> # In main.py
        >>> app.add_exception_handler(Exception, global_exception_handler)
        >>>
        >>> # When any route raises an exception
        >>> raise ValueError("Invalid symbol format")
        >>> # Response:
        >>> {
        >>>     "error_code": "ERR_VALUE",
        >>>     "error_type": "ValidationError",
        >>>     "message": "Invalid symbol format",
        >>>     "cause": "Input data failed validation rules. Details: Invalid symbol format",
        >>>     "impact": "Request rejected, no action taken",
        >>>     "remediation": "Fix input data according to validation rules, check schema documentation",
        >>>     "context": {...},
        >>>     "timestamp": "2025-10-24T10:30:00Z"
        >>> }
    """
    # Convert exception to SemanticError
    semantic_error = format_exception(
        exc,
        context={
            "request_path": str(request.url),
            "request_method": request.method,
        }
    )

    # Log semantic error to JSONL
    error_logger.log_semantic_error(semantic_error)

    # Determine HTTP status code based on error type
    status_code = _get_status_code(semantic_error.error_type, exc)

    # Return JSON response
    return JSONResponse(
        status_code=status_code,
        content=semantic_error.to_dict(),
    )


def _get_status_code(error_type: str, exc: Exception) -> int:
    """Determine HTTP status code from error type.

    Args:
        error_type: Classified error type (from error_formatter)
        exc: Original exception

    Returns:
        HTTP status code (400, 401, 404, 429, 500, 503)
    """
    # Map error types to HTTP status codes
    status_map: Dict[str, int] = {
        "ValidationError": 400,  # Bad Request
        "RiskControlError": 403,  # Forbidden (circuit breaker)
        "RetriableError": 503,  # Service Unavailable (retry)
    }

    # Check exception type for specific status codes
    exc_type_name = type(exc).__name__

    if "Unauthorized" in exc_type_name or "Auth" in exc_type_name:
        return 401  # Unauthorized

    if "NotFound" in exc_type_name:
        return 404  # Not Found

    if "RateLimit" in exc_type_name or "TooManyRequests" in exc_type_name:
        return 429  # Too Many Requests

    # Use error_type mapping
    if error_type in status_map:
        return status_map[error_type]

    # Default to 500 Internal Server Error
    return 500


class SemanticErrorResponse:
    """
    Pydantic-like response model for semantic errors.

    This is a simple dataclass for documentation purposes.
    Actual responses are generated by global_exception_handler.
    """

    error_code: str
    error_type: str
    message: str
    cause: str
    impact: str
    remediation: str
    context: Dict[str, Any]
    timestamp: str
